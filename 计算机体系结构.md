# 内存

## 缓存

### 缓存写入

#### write-through cache

写入缓存的时候,同时写入内存

#### write-back cache

只更新缓存,只有在数据被迫离开缓存时,才写入内存中

#### write-buffer

只要数据一进入buffer中,就立即缓存,而不是等待完全的延迟将数据写入内存中

### 未命中率 miss-rate

#### 三C模型

##### 强制性未命中(compulsory miss)

又称为冷启动未命中，因为缓存一开始是空的，这是对项目的第一次引用。

##### 容量未命中(capacity miss)

缓存的空间不足而不得不踢出一个项目以将新项目引入缓存。

##### 冲突未命中(conflict miss)

这种未命中出现在硬件中，因为硬件缓存中对项的放置位置有限制，这是由于所谓的集合关联性。它不会出现在操作系统页面缓存中，因为这样的缓存总是完全关联的，即对页面放置的内存位置没有限制。

冲突未命中（conflict miss) 和缓存的实现方式有关。大多数缓存，尤其是硬件缓存，由于它们需要设计的较为简单，因此限制了**块**可以被放置的位置。例如 block i 只能放在 block (**i mod cache size**) 的地方，以上图为例，缓存的大小为4，如果要取 block 8的数据，则只能放在缓存的第0块，同样，block 9 放在缓存的 block  1处。因此，如果要取的块为 block 0， block 4，block 8，那么计算出来都应该放在缓存 block 0的位置，因此放  block 4时，会覆盖原来 block 0的数据，加入需要循环的访问 block 0，block 8，block 0，block  8，这样就会一直不能命中，即使缓存有多余的空间，但位置的限制导致一直覆盖缓存上 block 0 的数据，造成**冲突未命中**。![image-20220830195516083](E:\笔记\计算机体系结构.assets\image-20220830195516083.png)

##### coherency miss 一致性

多线程以及多核增加了缓存的复杂性,引入第四个C coherency  
缓存刷新以保证多处理器中多个缓存一致

### 内存平均访问时间

![image-20220902115544778](E:\笔记\计算机体系结构.assets\image-20220902115544778.png)

