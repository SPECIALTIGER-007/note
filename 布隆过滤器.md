# 布隆过滤器

## 概念

是一种检索元素是否在给定大集合的数据结构,这种数据结构是高效且性能很好的,但是缺点是有一定的错误识别率和删除难度,并且理论上,添加到集合的元素越多,误报的可能性越大.

## 实现

由二进制向量(位数组)和一系列随机映射函数(哈希函数)两部分组成的数据结构.

相比于常用的List,Map,Set等数据结构,它占用空间更少并且效率更高,但是缺点是返回的结果是概率性的,而不是非常准确.

理论上添加到集合中的元素越多,误报的可能性越大,并且,存在在布隆过滤器的数据不容易被删除

> 位数组中的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。这样申请一个 100w 个元素的位数组只占用 1000000Bit / 8 = 125000 Byte = 125000/1024 kb ≈ 122kb 的空间。

## 原理介绍

当把一个元素加入布隆过滤器时,会进行下列操作:

1. 使用布隆过滤器中的哈希函数(有多个哈希函数)对元素值进行计算,得到哈希值(有几个哈希函数得到几个哈希值)
2. 根据得到的哈希值,在位数组中将对应下标的值置为1

当判断一个元素是否在布隆过滤器时,会进行下列操作:

1. 对给定元素进行相同的哈希运算
2. 将得到的哈希值(可能有多个哈希值),判断与位数组对应下标的值是否为1,如果都为1说明该元素在布隆过滤器中,如果存在一个值不为1,则说明该元素不在布隆过滤器中

> ![img](E:\笔记\布隆过滤器.assets\v2-31ae2b6e75d549f7e539f5d053c114c0_1440w.jpg)
>
> 如图所示，当字符串存储要加入到布隆过滤器中时，该字符串首先由多个哈希函数生成不同的哈希值，然后将对应的位数组的下标设置为 1（当位数组初始化时，所有位置均为 0）。当第二次存储相同字符串时，因为先前的对应位置已设置为  1，所以很容易知道此值已经存在（去重非常方便）。
>
> 如果我们需要判断某个字符串是否在布隆过滤器中时，只需要对给定字符串再次进行相同的哈希计算，得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。

不同的字符串可能哈希出来的位置相同，这种情况我们可以**适当增加位数组大小或者调整我们的哈希函数**。

## 总结特点

如果布隆过滤器说该元素在过滤器中,小概率会误判,但是如果布隆过滤器说某个元素不在,那么这个元素一定不在

## 使用场景

1. 判断给定数据是否存在: 比如判断一个数字是否存在于包含大量数字的数字集(数字集很大,5亿以上), 防止缓存穿透(判断请求的数据是否有效,避免直接绕过缓存去请求数据库), 邮箱的垃圾邮件过滤等
2. 去重: 比如爬给定网址的时候对已经爬取的URL进行去重

>  Google 开源的 Guava 中自带的布隆过滤器
>
> Guava 提供的布隆过滤器的实现还是很不错的（想要详细了解的可以看一下它的源码实现），但是它有一个重大的缺陷就是只能单机使用（另外，容量扩展也不容易），而现在互联网一般都是分布式的场景。为了解决这个问题，我们就需要用到 Redis 中的布隆过滤器了。

> Redis v4.0 之后有了 Module（模块/插件） 功能，Redis Modules 让 Redis 可以使用外部模块扩展其功能 。布隆过滤器就是其中的 Module。详情可以查看 Redis 官方对 Redis Modules 的介绍 ：[https://redis.io/modules](https://link.zhihu.com/?target=https%3A//redis.io/modules)