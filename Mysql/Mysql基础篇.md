## SELECT语句在MySQL中的执行过程

![image-20221012203015282](E:\笔记\Mysql\Mysql基础篇.assets\image-20221012203015282.png)

可以看到， MySQL 的架构共分为两层：**Server 层和存储引擎层**，

- **Server 层负责建立连接、分析和执行 SQL**。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。
- **存储引擎层负责数据的存储和提取**。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎是 InnoDB，从  MySQL 5.5 版本开始， InnoDB 成为了 MySQL  的默认存储引擎。我们常说的索引数据结构，就是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型是 B+树 ，且是默认使用，也就是说在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引。

### 第一步：连接器

连接的过程需要先经过 TCP 三次握手，因为 MySQL 是基于 TCP 协议进行传输的

使用长连接的好处就是可以减少建立连接和断开连接的过程，所以一般是推荐使用长连接。  
但是，使用长连接后可能会占用内存增多，因为 MySQL 在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开时才会释放。如果长连接累计很多，将导致 MySQL  服务占用内存太大，有可能会被系统强制杀掉，这样会发生 MySQL 服务异常重启的现象。

#### 长连接占用内存过多的两种解决方式

第一种，**定期断开长连接**。既然断开连接后就会释放连接占用的内存资源，那么我们可以定期断开长连接。

第二种，**客户端主动重置连接**。MySQL 5.7 版本实现了 `mysql_reset_connection()` 函数的接口，注意这是接口函数不是命令，那么当客户端执行了一个很大的操作后，在代码里调用 mysql_reset_connection 函数来重置连接，达到释放内存的效果。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。

#### 总结：

- 与客户端进行 TCP 三次握手建立连接；
- 校验客户端的用户名和密码，如果用户名或密码不对，则会报错；
- 如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；

### 第二步：查询缓存

 MySQL 8.0 开始，执行一条 SQL 查询语句，不会再走到查询缓存这个阶段了。

对于 MySQL 8.0 之前的版本，如果想关闭查询缓存，我们可以通过将参数 query_cache_type 设置成 DEMAND。

> TIP
>
> 这里说的查询缓存是 server 层的，也就是 MySQL 8.0 版本移除的是 server 层的查询缓存，并不是 Innodb 存储引擎中的 buffer poll。

### 第三步：解析SQL

#### 解析器解析SQL

##### 第一步：词法分析

解析器构建SQL语法树，这样方便后面模块获取SQL类型、表名、字段名、where条件等

##### 第二步：语法分析

语法解析器根据语法规则，判断输入的SQL语句是否满足MySQL语法。

如果输入的语法不对，就会在解析器这个阶段报错，比如`from`写成了`form`，就会报错，例如

```sql
select *
form test_day;
```

```
[2022-10-17 16:54:17] [42000][1064] You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'form test_day' at line 2
```

### 第四步：执行SQL

每条select语句可以分为下面三个阶段

1. prepare阶段：预处理阶段
2. optimize阶段：优化阶段
3. execute阶段：执行阶段

#### 预处理器

- 检查SQL查询语句中的表或者字段是否存在
- 将select * 中的 * 字符扩展为表中的所有列

#### 优化器

优化器主要负责将SQL查询语句的执行方案，比如表中有多个索引，优化器会基于查询成本的考虑，决定使用哪个索引。

在查询语句的最前面加上`explain`，就会输出这条SQL语句的执行计划，其中key的值表示使用的索引。

```mysql
explain
select `primary`
from test_index
where second = 2 and three = 3 ;
```

![image-20221018161653118](E:\笔记\Mysql\Mysql基础篇.assets\image-20221018161653118.png)

key的值`u_index`为索引名称

如果查询语句是覆盖索引，那么直接在二级索引中就能查找到结果（因为二级索引的B+树的叶子结点的数据存储的是主键值），就没必要在主键索引中查找了，因为查询主键索引的 B+ 树的成本会比查询二级索引的 B+ 的成本大，优化器基于查询成本的考虑，会选择查询代价小的普通索引。

#### 执行器

确定完执行方案后，MySQL开始真正执行语句，这个工作由执行器完成，在执行过程中，执行器会和**存储引擎**进行交互，交互是以记录为单位的

执行过程由三种方式

1. 主键索引查询
2. 全表扫描
3. 索引下推

##### 主键索引查询

> 以本文开头查询语句为例，看看执行器是怎么工作的。
>
> ```sql
> select * from product where id = 1;
> ```
>
> 这条查询语句的查询条件用到了主键索引，而且是等值查询，同时主键 id 是唯一，不会有 id 相同的记录，所以优化器决定选用访问类型为 const 进行查询，也就是使用主键索引查询一条记录，那么执行器与存储引擎的执行流程是这样的：
>
> - 执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为 InnoDB 引擎索引查询的接口，把条件 `id = 1` 交给存储引擎，**让存储引擎定位符合条件的第一条记录**。
> - 存储引擎通过主键索引的 B+ 树结构定位到 id = 1的第一条记录，如果记录是不存在的，就会向执行器上报记录找不到的错误，然后查询结束。如果记录是存在的，就会将记录返回给执行器；
> - 执行器从存储引擎读到记录后，接着判断记录是否符合查询条件，如果符合则发送给客户端，如果不符合则跳过该记录。
> - 执行器查询的过程是一个 while 循环，所以还会再查一次，但是这次因为不是第一次查询了，所以会调用 read_record  函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为一个永远返回 - 1  的函数，所以当调用该函数的时候，执行器就退出循环，也就是结束查询了。
>
> 至此，这个语句就执行完成了。

##### 全表扫描

> 举个全表扫描的例子：
>
> ```text
> select * from product where name = 'iphone';
> ```
>
> 这条查询语句的查询条件没有用到索引，所以优化器决定选用访问类型为 ALL 进行查询，也就是全表扫描的方式查询，那么这时执行器与存储引擎的执行流程是这样的：
>
> - 执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 all，这个函数指针被指向为 InnoDB 引擎全扫描的接口，**让存储引擎读取表中的第一条记录**；
> - 执行器会判断读到的这条记录的 name 是不是 iphone，如果不是则跳过；如果是则将记录发给客户的（是的没错，Server  层每从存储引擎读到一条记录就会发送给客户端，之所以客户端显示的时候是直接显示所有记录的，是因为客户端是等查询语句查询完成后，才会显示出所有的记录）。
> - 执行器查询的过程是一个 while 循环，所以还会再查一次，会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为  all，read_record 函数指针指向的还是 InnoDB  引擎全扫描的接口，所以接着向存储引擎层要求继续读刚才那条记录的下一条记录，存储引擎把下一条记录取出后就将其返回给执行器（Server层），执行器继续判断条件，不符合查询条件即跳过该记录，否则发送到客户端；
> - 一直重复上述过程，直到存储引擎把表中的所有记录读完，然后向执行器（Server层） 返回了读取完毕的信息；
> - 执行器收到存储引擎报告的查询完毕的信息，退出循环，停止查询。
>
> 至此，这个语句就执行完成了。

##### 索引下推

> 在这部分非常适合讲索引下推（MySQL 5.6 推出的查询优化策略），这样大家能清楚的知道，「下推」这个动作，下推到了哪里。
>
> 索引下推能够减少**二级索引**在查询时的回表操作，提高查询的效率，因为它将 Server 层部分负责的事情，交给存储引擎层去处理了。
>
> 举一个具体的例子，方便大家理解，这里一张用户表如下，我对 age 和 reward 字段建立了联合索引（age，reward）：
>
> ![img](E:\笔记\Mysql\Mysql基础篇.assets\路飞表.png)
>
> 现在有下面这条查询语句：
>
> ```sql
> select * from t_user  where age > 20 and reward = 100000;
> ```
>
> 联合索引当遇到范围查询 (>、<、between、like) 就会停止匹配，也就是 **age 字段能用到联合索引，但是 reward 字段则无法利用到索引**。)
>
> 那么，不使用索引下推（MySQL 5.6 之前的版本）时，执行器与存储引擎的执行流程是这样的：
>
> - Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到 age > 20 的第一条记录；
> - 存储引擎根据二级索引的 B+ 树快速定位到这条记录后，获取主键值，然后**进行回表操作**，将完整的记录返回给 Server 层；
> - Server 层在判断该记录的 reward 是否等于 100000，如果成立则将其发送给客户端；否则跳过该记录；
> - 接着，继续向存储引擎索要下一条记录，存储引擎在二级索引定位到记录后，获取主键值，然后回表操作，将完整的记录返回给 Server 层；
> - 如此往复，直到存储引擎把表中的所有记录读完。
>
> 可以看到，没有索引下推的时候，每查询到一条二级索引记录，都要进行回表操作，然后将记录返回给 Server，接着 Server 再判断该记录的 reward 是否等于 100000。
>
> 而使用索引下推后，判断记录的 reward 是否等于 100000 的工作交给了存储引擎层，过程如下 ：
>
> - Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到 age > 20 的第一条记录；
> - 存储引擎定位到二级索引后，**先不执行回表**操作，而是先判断一下该索引中包含的列（reward列）的条件（reward 是否等于 100000）是否成立。如果**条件不成立**，则直接**跳过该二级索引**。如果**成立**，则**执行回表**操作，将完成记录返回给 Server 层。
> - Server 层在判断其他的查询条件（本次查询没有其他条件）是否成立，如果成立则将其发送给客户端；否则跳过该记录，然后向存储引擎索要下一条记录。
> - 如此往复，直到存储引擎把表中的所有记录读完。
>
> 可以看到，使用了索引下推后，虽然 reward 列无法使用到联合索引，但是因为它包含在联合索引（age，reward）里，所以直接在存储引擎过滤出满足  reward =  100000 的记录后，才去执行回表操作获取整个记录。相比于没有使用索引下推，节省了很多回表操作。
>
> 当你发现执行计划里的 Extr 部分显示了 “Using index condition”，说明使用了索引下推。
>
> ![img](E:\笔记\Mysql\Mysql基础篇.assets\索引下推执行计划.png)

### 总结

执行一条 SQL 查询语句，期间发生了什么？

- 连接器：建立连接，管理连接、校验用户身份；
- 查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；
- 解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；
- 执行 SQL：执行 SQL 共有三个阶段：
  - 预处理阶段：检查表或字段是否存在；将 `select *` 中的 `*` 符号扩展为表上的所有列。
  - 优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；
  - 执行阶段：根据执行计划执行  SQL 查询语句，从存储引擎读取记录，返回给客户端；
