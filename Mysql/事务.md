## 事务的四个特性（ACID）

- 原子性
- 一致性
- 隔离性
- 持久性

Innodb通过四个技术保证这四个特性

- redo log（重做日志） 保证持久性
- undo log（回滚日志） 保证原子性
- MVCC（多版本并发控制）或锁机制 保证隔离性
- 持久性+原子性+隔离性 保证一致性

## 事务中数据不一致的三种现象

### 脏读（dirty read）

一个事务读到了另一个未提交事务修改过的数据。

### 不可重复读（non-repeatable read）

在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了 **不可重复读** 现象

比如事务A从数据库中读取数据x，然后执行后续操作，此时，事务B提交，更新了数据x的值，那么当事务A再次读取数据x时，会发现两次读到的数据不一致，这就是不可重复读现象。

### 幻读（phantom read）

在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。

幻读与不可重复读的区别：

二者很相似，不可重复读指的是对同一条记录（可以理解为对同一行）前后两次的读取结果是不一样的。
幻读指的是一个事务读取两次，得到的记录条数不一致。
幻读和不可重复读都是读取了另一条已经提交的事务(这点就脏读不同)，所不同的是不可重复读可能发生在update操作中，而幻读发生在insert，delete操作中。

### 这三个现象的严重性排序：

![图片](E:\笔记\Mysql\事务.assets\d37bfa1678eb71ae7e33dc8f211d1ec1.png)

## 事务的隔离级别

- **读未提交（\*read uncommitted\*）**，指一个事务还没提交时，它做的变更就能被其他事务看到；
- **读提交（\*read committed\*）**，指一个事务提交之后，它做的变更才能被其他事务看到；
- **可重复读（\*repeatable read\*）**，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，**MySQL InnoDB 引擎的默认隔离级别**；
- **串行化（\*serializable\* ）**；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；

![image-20221024083907491](E:\笔记\Mysql\事务.assets\image-20221024083907491.png)

**MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了，详见这篇(https://xiaolincoding.com/mysql/transaction/phantom.html)，解决的方案有两种：

- 针对**快照读**（普通 select 语句），是**通过 MVCC 方式解决了幻读**，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。
- 针对**当前读**（select ... for update 等语句），是**通过 next-key lock（记录锁+间隙锁）方式解决了幻读**，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。

### Read View

对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同：

- 「读提交」隔离级别是在每个 select 都会生成一个新的 Read View，也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。
- 「可重复读」隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View，这样就保证了在事务期间读到的数据都是事务启动前的记录。

这两个隔离级别实现是通过「事务的 Read View 里的字段」和「记录中的两个隐藏列」的比对，来控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）。

在可重复读隔离级别中，普通的 select 语句就是基于 MVCC 实现的快照读，也就是不会加锁的。而 select .. for update  语句就不是快照读了，而是当前读了，也就是每次读都是拿到最新版本的数据，但是它会对读到的记录加上 next-key lock 锁。

