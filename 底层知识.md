# I/O多路复用

## 概念

普通的阻塞型I/O，若是没有数据可读，就会发生阻塞，若是使用多线程的话，大量的线程会导、致性能的下降。关键问题是，如何知道文件描述符对应I/O设备是否处于可读，或者可写的状态？

### 方法：使用内核主动监视文件描述符

好处是可以减少线程切换的损耗，以及内核态频繁转换为用户态的损耗

### 要点

通过函数参数的方式，将文件描述符的集合传递给内核，当这些文件描述符中有可读的I/O操作时，再返回

## Linux的三个I/O多路复用函数

### select

将要监视的文件描述符集合通过函数参数的方式告诉select，然后，select会将**文件描述符的集合拷贝到内核中**，（每次调用select都要将文件描述符集合从用户空间拷贝到内核空间，并且**内核需要遍历文件描述符集合**）这个过程中数据拷贝会造成较大的数据损耗，因此Linux限制集合最大为1024个，当select返回时，仅仅只能知道有些文件描述符可以读写，但是不知道是**具体的哪一个**

### poll

在select的基础上，去除了集合大小的限制

### **epoll**

分为三个函数：

1. epoll_create：创建一个epoll句柄
2. epoll_ctl：注册要监听的事件类型
3. epoll_wait：等待事件发生

在解决了集合大小的基础上，并且只操作那些有变化的文件描述符，同时和内核共享了同一块内存，这个内存保存了那些已经可读或可写的文件描述符，这样可以减少内核和程序的拷贝开销（epoll只需要拷贝一次）。

最重要的是，使用了事件驱动机制（Event-driven），不需要主动轮询文件描述符，而是让文件描述符可读或可写时，主动报告。

# 协程

# Thread Local Storage (TLS)

## 概念

存放在该区域中的变量是全局变量，所有线程都可以访问

虽然看上去所有线程访问的都是同一个变量，但该全局变量独属于一个线程，一个线程对此变量的修改对其他线程不可见。

例如

```c
int a = 1; // 全局变量

void print_a() {
    cout<<a<<endl;
}

void run() {
    ++a;
    print_a();
}

void main() {
    thread t1(run);
    t1.join();

    thread t2(run);
    t2.join();
}
```

经过这段代码后，变量a自增两次，输出

```
2
3
```

但是如果变量a这么定义

```c
__thread int a = 1; // 线程局部存储
```

那么结果为

```
2
2
```

线程t1对变量a的修改不会影响到线程t2，线程t1在将变量a加到1后变为2，但对于线程t2来说此时变量a依然是1，因此加1后依然是2。

## 总结

**线程局部存储可以让你使用一个独属于线程的全局变量**。也就是说，虽然该变量可以被所有线程访问，但该变量在每个线程中都有一个副本，一个线程对改变量的修改不会影响到其它线程。

# malloc申请内存

1. malloc开始搜索空闲的内存块，如果找到一块合适的，就分配出去
2. 如果找不到，就调用brk等系统调用扩大堆区，从而获得更大的空闲内存
3. 调用brk后，开始转入内核态，此时，操作系统的虚拟内存系统开始工作，扩大进程的堆区，但是并没有分配真正的物理内存
4. brk返回到malloc后，从内核态切换到用户态，malloc找到一块空闲内存后返回
5. 程序拿到新申请的内存，程序继续
6. 当代码读写到新申请的内存时，会进入内核态，触发缺页错误（缺页中断），操作系统此时才真正的分配物理内存，之后再次从内核态切换回用户态，程序继续

![image-20221008141639428](E:\笔记\底层知识.assets\image-20221008141639428.png)

![image-20221008141651708](E:\笔记\底层知识.assets\image-20221008141651708.png)

# CPU在空闲时干什么

CPU 空闲时执行特定的 halt 指令

```c
while (1) {
  while(!need_resched()) {
      cpuidle_idle_call();
  }
}
```

Linux内核中，代码部分实现，实质还是调用halt指令

> halt指令是特权指令，只有在内核态才会执行，这条指令会让部分CPU进入休眠状态，从而**极大减少对电力的消耗**

**问题：如何跳出while循环**

# 为什么SSD不能当做内存

## 二者读取粒度不同

内存的读取粒度是以byte为单位，而ssd的读取粒度是以块为单位

若是用ssd替代内存的话，无法访问文件中某个特定的字节。

CPU没有办法像访问内存那样直接按照字节粒度去SSD中寻址，CPU访问SSD(磁盘)通常需要借助文件系统，当然，**我们也有办法绕开文件系统**，但CPU依然无法直接访问SSD(磁盘)中的某个字节。

> 磁盘块（虚拟）是操作系统中最小的逻辑存储单位。操作系统与磁盘打交到的最小单位是磁盘块。一个块大小=一个扇区大小*2的n次方

## SSD的总写入字节有限

# CPU如何读写内存

## 为什么要读写内存？

1. 程序运行时需要内存中的数据
2. CPU需要访问内存读取下一条要执行的机器指令

## 问题一：CPU执行速度远远大于内存的读写速度

会造成CPU执行一条要读写内存的指令要消耗大量的时间。

## 解决方法：使用缓存

CPU访问内存时，先访问缓存（比如SRAM，读写速度介于CPU和内存之间），原理是利用时间局部性和空间局部性

### write-through和write-back

write-though：CPU更新cache时，一并更新内存。   
缺点是：效率低，若是CPU写cache时，cache中没有相应的内存数据，需要先把数据从内存中加载到cache中，然后更新cache，再更新内存

write-back：当需要更新cache时，CPU直接更新cache，当包含该数据的cache块被剔除时，再更新到内存

### 多级cache

## 问题二：多核CPU下缓存不一致的问题

CPU的每个核心都有各自的cache，CPU在更新变量时，需要将所有拥有该变量的cache都进行更新。

实际上，现代CPU有一套协议来维护缓存的一致性，比如经典的MESI协议等。

## 虚拟内存

现代CPU使用MMU（Memory Management Unit）模块将虚拟地址转换为物理地址。

当查内存未命中时，可能还需要到磁盘中查找（虚拟内存将数据存放在磁盘中）

# CPU缓存一致性协议-MESI协议

MESI协议实际上是四个单词的首字母缩写

- Modified 已修改
- Exclusive 独占
- Shared 共享
- Invalidated 失效的

「已修改」状态就是我们前面提到的脏标记，代表该 Cache Block 上的数据已经被更新过，但是还没有写到内存里。而「已失效」状态，表示的是这个 Cache Block 里的数据已经失效了，不可以读取该状态的数据。

「独占」和「共享」状态都代表 Cache Block 里的数据是干净的，也就是说，这个时候 Cache Block 里的数据和内存里面的数据是一致性的。

「独占」和「共享」的差别在于，独占状态的时候，数据只存储在一个 CPU 核心的 Cache 里，而其他 CPU 核心的 Cache 没有该数据。这个时候，如果要向独占的 Cache  写数据，就可以直接自由地写入，而不需要通知其他 CPU 核心，因为只有你这有这个数据，就不存在缓存一致性的问题了，于是就可以随便操作该数据。

另外，在「独占」状态下的数据，如果有其他核心从内存读取了相同的数据到各自的 Cache ，那么这个时候，独占状态下的数据就会变成共享状态。

那么，「共享」状态代表着相同的数据在多个 CPU 核心的 Cache 里都有，所以当我们要更新 Cache 里面的数据的时候，不能直接修改，而是要先向所有的其他 CPU  核心广播一个请求，要求先把其他核心的 Cache 中对应的 Cache Line 标记为「无效」状态，然后再更新当前 Cache 里面的数据。

