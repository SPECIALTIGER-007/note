# 简单动态字符串（SDS,simple dynamic string）

```c
struct sdshdr {
    // 记录buf数组中已使用字节的数量
    // 等于SDS所保存字符串的长度
    int len;
    // 记录buf数组中未使用字节的数量
    int free;
    // 字节数组，用于保存字符串
    char buf[];
};
```

buf和c语言的字符串类型一样，以空字符('\0')结尾，不同的是，len计算长度时，不计算最后空字符的长度。遵循同样以空字符结尾的好处是，SDS可以直接重用一部分C字符串函数库里面的函数。

## redis中使用sds而不用c字符串

#### 1）常数复杂度获取字符串长度。

通过一个额外的属性,len记录字符串的长度,而C字符串获取长度需要遍历字符数组

#### 2）杜绝缓冲区溢出。

使用C字符串时,如果在增加字符串长度时,忘记重新分配额外的空间的话,就有可能出现缓冲区溢出,导致修改了相邻内存地址里的值 

使用sds的api时,api会自动检查sds的空间是否满足要求,并自动扩展,所以不用手动修改sds的空间大小,也就不会出现缓冲区溢出

#### 3）减少修改字符串长度时所需的内存重分配次数。

C字符串每一次改变长度,都需要进行内存重分配,而Redis作为数据库,对速度要求严苛,且经常需要更改数据,使用C字符串不符合性能要求

基于未使用空间,Redis实现了空间预分配和惰性空间释放两种优化策略

##### 空间预分配

sds进行空间扩展时,不仅为sds分配修改所必要的空间,还会为sds分配额外的未使用的空间

如果对sds修改后,len的值小于1MB,那么分配和len属性大小一样的未使用空间,此时len属性和free属性的值相同.		例如:修改后len的值为13字节,则free的值也为13,字节buf数组的实际长度为:13+13+1  = 27字节(1是空字符).

如果对sds修改后,len的值大等于1MB,则分配1MB的未使用空间,free属性的值为1MB

即len小于1MB时,分配与len大小相等的未使用空间;len大于等于1MB时,分配1MB的未使用空间.

通过这种策略,Redis将连续执行字符串增长N次所需的内存重分配操作

##### 惰性空间释放

当sds的API需要缩短sds所保存的字符串时,程序并不立即内存重分配来回收缩短后多出来的字节,而是使用free收集出来,并等待将来使用

当然sds也有专门API用来真正的释放sds未使用的空间

#### 4）二进制安全。

##### 什么是二进制安全?

将输入流作为原始的,无任何特殊格式意义的数据流

C字符串必须符合某种编码(比如ASCII),并且除了末尾的空字符外,字符串内不能包含空字符(因为可能会导致字符串被错误的分割),因此只能保存文本数据,而不能保存图片,视频等二进制数据

而sds的API都是二进制安全的,程序不会对其中的数据做任何限制,过滤或者假设,因此buf属性也称为字节数组,并且sds通过len记录长度,可以保存空字符

#### 5）兼容部分C字符串函数。

通过遵循C字符串以空字符结尾的惯例，SDS可以在有需要时重用<string.h>函数库，从而避免了不必要的代码重复。

# 链表

除了链表键,发布与订阅,慢查询,监视器等功能也用到了链表,redis还用链表保存多个客户端的状态信息,使用链表构建客户端输出缓冲区

```c
typedef struct list {
    // 
表头节点
    listNode * head;
    // 
表尾节点
    listNode * tail;
    // 
链表所包含的节点数量
    unsigned long len;
    // 
节点值复制函数
    void *(*dup)(void *ptr);
    // 
节点值释放函数
    void (*free)(void *ptr);
    // 
节点值对比函数
    int (*match)(void *ptr,void *key);
} list;
```

## 特性

1. 双端 因为有头尾指针,获取某个节点的前置和后置节点的复杂度都为O(1)
2. 无环 头指针的prev和尾指针的next都指向NULL
3. 带表头和表尾指针
4. 带链表长度计数器
5. 多态  
   链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。

# 字典

又称符号表(symbol table),关联数组(associative array),映射(map),是一种保存键值对的数据结构

Redis的数据库就是使用字典来作为底层实现的，对数据库的增、删、查、改操作也是构建在对字典的操作之上的

除了用来表示数据库之外，字典还是哈希键的底层实现之一，当一个哈希键包含的键值对比较多，又或者键值对中的元素都是比较长的字符串时，Redis就会使用字典作为哈希键的底层实现

哈希表

```c
typedef struct dictht {
    // 
哈希表数组
    dictEntry **table;
    // 
哈希表大小
    unsigned long size;
    //
哈希表大小掩码，用于计算索引值
    //
总是等于size-1
    unsigned long sizemask;
    // 
该哈希表已有节点的数量
    unsigned long used;
} dictht;
```

哈希表节点

```c
typedef struct dictEntry {
    // 键
    void *key;
    // 值
    union{
        void *val;
        uint64_tu64;
        int64_ts64;
    } v;
    // 指向下个哈希表节点，形成链表
    struct dictEntry *next;
} dictEntry;
```

