## 简单动态字符串（SDS,simple dynamic string）

```c
struct sdshdr {
    // 记录buf数组中已使用字节的数量
    // 等于SDS所保存字符串的长度
    int len;
    // 记录buf数组中未使用字节的数量
    int free;
    // 字节数组，用于保存字符串
    char buf[];
};
```

buf和c语言的字符串类型一样，以空字符('\0')结尾，不同的是，len计算长度时，不计算最后空字符的长度。遵循同样以空字符结尾的好处是，SDS可以直接重用一部分C字符串函数库里面的函数。

### redis中使用sds而不用c字符串

#### 1）常数复杂度获取字符串长度。

通过一个额外的属性,len记录字符串的长度,而C字符串获取长度需要遍历字符数组

#### 2）杜绝缓冲区溢出。

使用C字符串时,如果在增加字符串长度时,忘记重新分配额外的空间的话,就有可能出现缓冲区溢出,导致修改了相邻内存地址里的值 

使用sds的api时,api会自动检查sds的空间是否满足要求,并自动扩展,所以不用手动修改sds的空间大小,也就不会出现缓冲区溢出

#### 3）减少修改字符串长度时所需的内存重分配次数。

C字符串每一次改变长度,都需要进行内存重分配,而Redis作为数据库,对速度要求严苛,且经常需要更改数据,使用C字符串不符合性能要求

基于未使用空间,Redis实现了空间预分配和惰性空间释放两种优化策略

##### 空间预分配

sds进行空间扩展时,不仅为sds分配修改所必要的空间,还会为sds分配额外的未使用的空间

如果对sds修改后,len的值小于1MB,那么分配和len属性大小一样的未使用空间,此时len属性和free属性的值相同.		例如:修改后len的值为13字节,则free的值也为13,字节buf数组的实际长度为:13+13+1  = 27字节(1是空字符).

如果对sds修改后,len的值大等于1MB,则分配1MB的未使用空间,free属性的值为1MB

即len小于1MB时,分配与len大小相等的未使用空间;len大于等于1MB时,分配1MB的未使用空间.

通过这种策略,Redis将连续执行字符串增长N次所需的内存重分配操作

##### 惰性空间释放

当sds的API需要缩短sds所保存的字符串时,程序并不立即内存重分配来回收缩短后多出来的字节,而是使用free收集出来,并等待将来使用

当然sds也有专门API用来真正的释放sds未使用的空间

#### 4）二进制安全。

##### 什么是二进制安全?

将输入流作为原始的,无任何特殊格式意义的数据流

C字符串必须符合某种编码(比如ASCII),并且除了末尾的空字符外,字符串内不能包含空字符(因为可能会导致字符串被错误的分割),因此只能保存文本数据,而不能保存图片,视频等二进制数据

而sds的API都是二进制安全的,程序不会对其中的数据做任何限制,过滤或者假设,因此buf属性也称为字节数组,并且sds通过len记录长度,可以保存空字符

#### 5）兼容部分C字符串函数。

通过遵循C字符串以空字符结尾的惯例，SDS可以在有需要时重用<string.h>函数库，从而避免了不必要的代码重复。